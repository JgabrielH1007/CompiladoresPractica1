package com.mycompany.analizadores;

import java_cup.runtime.*;
import java.util.*;

parser code {:
    Lexer lexer;
    private List<ErrorSintactico> erroresSintacticos;
    private List<ReporteOperador> operadores = new ArrayList<>();
    private List<ReporteControl> estructuras = new ArrayList<>();

    public List<ReporteOperador> getOperadores() { return operadores; }
    public List<ReporteControl> getEstructuras() { return estructuras; }

    public Parser(Lexer lexer) {
        super(lexer);
        this.lexer = lexer;
        erroresSintacticos = new ArrayList<>();
    }

    public Lexer getLexer(){
        return this.lexer;
    }
    
    public List<ErrorSintactico> getSintaxError(){
        return erroresSintacticos; 
    }

    @Override
    public void syntax_error(Symbol cur_token){
        String lexema = (cur_token.value != null) ? cur_token.value.toString() : symbl_name_from_id(cur_token.sym);
        
        int linea = cur_token.left;
        int columna = cur_token.right;
        
        StringBuilder descripcion = new StringBuilder();
        if( expected_token_ids().isEmpty()  ){
            descripcion.append("Ya no se esperaba ningun simbolo");
        } else {
            descripcion.append("Se esperaba: ");
            for(Integer expected_token_id : expected_token_ids() ){ 
                if(!symbl_name_from_id(expected_token_id).equals("error")){
                    descripcion.append(symbl_name_from_id(expected_token_id));
                    descripcion.append(" ");
                }
            }
        }
        
        erroresSintacticos.add(new ErrorSintactico(lexema, linea, columna, descripcion.toString())); 
    }

    @Override
    public void unrecovered_syntax_error(Symbol cur_token){
        String lexema = (cur_token.value != null) ? cur_token.value.toString() : symbl_name_from_id(cur_token.sym);
        erroresSintacticos.add(new ErrorSintactico(lexema, cur_token.left, cur_token.right, "Error sintáctico irrecuperable."));
    }
:};

/* terminales */

terminal INICIO, FIN;
terminal SI, ENTONCES;
terminal MIENTRAS, HACER;
terminal MOSTRAR, LEER, VAR;
terminal SEPARADOR;

terminal DEFAULT;
terminal COLOR_TEXTO_SI, COLOR_SI, FIGURA_SI, LETRA_SI, LETRA_SIZE_SI;
terminal COLOR_TEXTO_MIENTRAS, COLOR_MIENTRAS, FIGURA_MIENTRAS, LETRA_MIENTRAS, LETRA_SIZE_MIENTRAS;
terminal COLOR_TEXTO_BLOQUE, COLOR_BLOQUE, FIGURA_BLOQUE, LETRA_BLOQUE, LETRA_SIZE_BLOQUE;

terminal ELIPSE, CIRCULO, PARALELOGRAMO, RECTANGULO, ROMBO, RECTANGULO_REDONDEADO;
terminal ARIAL, TIMES_NEW_ROMAN, COMIC_SANS, VERDANA;

terminal PARENTESIS_ABIERTO, PARENTESIS_CERRADO;
terminal MAS, MENOS, MULTIPLICADO, DIVIDIDO;
terminal IGUAL, IGUAL_IGUAL, DIFERENTE;
terminal MENOR, MAYOR, MENOR_IGUAL, MAYOR_IGUAL;
terminal AND, OR, NOT;
terminal COMA;
terminal PIPE; 

terminal String CADENA;
terminal Integer ENTERO;
terminal Double DECIMAL;
terminal String ID;
terminal String COLOR_HEX;

/* no terminales */

non terminal programa;
non terminal bloque_codigo;
non terminal lista_sentencias;
non terminal sentencia;
non terminal condicion;
non terminal expresion, termino, factor;
non terminal bloque_config;
non terminal lista_config;
non terminal instruccion_config;
non terminal color;
non terminal rgb;
non terminal figura;
non terminal letra;

/* precedencia por si acaso */

precedence left OR;
precedence left AND;
precedence left IGUAL_IGUAL, DIFERENTE;
precedence left MENOR, MAYOR, MENOR_IGUAL, MAYOR_IGUAL;
precedence left MAS, MENOS;
precedence left MULTIPLICADO, DIVIDIDO;
precedence right NOT;

start with programa;


programa ::=
        bloque_codigo
        | bloque_codigo SEPARADOR bloque_config
        | error SEPARADOR bloque_config 
        ;

bloque_codigo ::=
        INICIO lista_sentencias FIN
        | INICIO error FIN 
        ;

lista_sentencias ::=
        lista_sentencias sentencia
        | sentencia
        | lista_sentencias error sentencia 
        | error sentencia               
        ;

sentencia ::=
        VAR ID IGUAL expresion
        | ID IGUAL expresion
        | MOSTRAR CADENA
        | MOSTRAR ID
        | LEER ID
        | SI:s PARENTESIS_ABIERTO condicion:c PARENTESIS_CERRADO ENTONCES lista_sentencias FIN SI {:
            estructuras.add(new ReporteControl("SI", sleft, String.valueOf(c)));
        :}
        | SI error ENTONCES lista_sentencias FIN SI 
        
        | MIENTRAS:m PARENTESIS_ABIERTO condicion:c PARENTESIS_CERRADO HACER lista_sentencias FIN MIENTRAS {:
            estructuras.add(new ReporteControl("MIENTRAS", mleft, String.valueOf(c)));
        :}
        | MIENTRAS error HACER lista_sentencias FIN MIENTRAS
        ;

condicion ::=
        expresion:e1 IGUAL_IGUAL expresion:e2 {: RESULT = e1 + " == " + e2; :}
        | expresion:e1 DIFERENTE expresion:e2 {: RESULT = e1 + " != " + e2; :}
        | expresion:e1 MENOR expresion:e2 {: RESULT = e1 + " < " + e2; :}
        | expresion:e1 MAYOR expresion:e2 {: RESULT = e1 + " > " + e2; :}
        | expresion:e1 MENOR_IGUAL expresion:e2 {: RESULT = e1 + " <= " + e2; :}
        | expresion:e1 MAYOR_IGUAL expresion:e2 {: RESULT = e1 + " >= " + e2; :}
        | condicion:c1 AND condicion:c2 {: RESULT = c1 + " AND " + c2; :}
        | condicion:c1 OR condicion:c2 {: RESULT = c1 + " OR " + c2; :}
        | NOT condicion:c {: RESULT = "NOT " + c; :}
        | PARENTESIS_ABIERTO condicion:c PARENTESIS_CERRADO {: RESULT = "(" + c + ")"; :}
        ;

expresion ::=
        expresion:e1 MAS:op termino:e2 {: 
            String occ = e1 + " + " + e2;
            operadores.add(new ReporteOperador("Suma", opleft, opright, occ));
            RESULT = occ; 
        :}
        | expresion:e1 MENOS:op termino:e2 {: 
            String occ = e1 + " - " + e2;
            operadores.add(new ReporteOperador("Resta", opleft, opright, occ));
            RESULT = occ; 
        :}
        | termino:t {: RESULT = t; :}
        ;

termino ::=
        termino:t1 MULTIPLICADO:op factor:t2 {: 
            String occ = t1 + " * " + t2;
            operadores.add(new ReporteOperador("Multiplicación", opleft, opright, occ));
            RESULT = occ; 
        :}
        | termino:t1 DIVIDIDO:op factor:t2 {: 
            String occ = t1 + " / " + t2;
            operadores.add(new ReporteOperador("División", opleft, opright, occ));
            RESULT = occ; 
        :}
        | factor:f {: RESULT = f; :}
        ;

factor ::=
        ENTERO:e {: RESULT = String.valueOf(e); :}
        | DECIMAL:d {: RESULT = String.valueOf(d); :}
        | ID:id {: RESULT = String.valueOf(id); :}
        | PARENTESIS_ABIERTO expresion:e PARENTESIS_CERRADO {: RESULT = "(" + e + ")"; :}
        ;

/* configuracion */ 

bloque_config ::=
        lista_config
        ;

lista_config ::=
        lista_config instruccion_config
        | instruccion_config
        | lista_config error instruccion_config /* RECUPERACION: Si una config falla, salta a la siguiente */
        | error instruccion_config              /* RECUPERACION: Si la primera config falla */
        ;

instruccion_config ::=
        DEFAULT IGUAL expresion
        | COLOR_TEXTO_SI IGUAL color PIPE expresion
        | COLOR_SI IGUAL color PIPE expresion
        | FIGURA_SI IGUAL figura PIPE expresion
        | LETRA_SI IGUAL letra PIPE expresion
        | LETRA_SIZE_SI IGUAL expresion PIPE expresion
        | COLOR_TEXTO_MIENTRAS IGUAL color PIPE expresion
        | COLOR_MIENTRAS IGUAL color PIPE expresion
        | FIGURA_MIENTRAS IGUAL figura PIPE expresion
        | LETRA_MIENTRAS IGUAL letra PIPE expresion
        | LETRA_SIZE_MIENTRAS IGUAL expresion PIPE expresion
        | COLOR_TEXTO_BLOQUE IGUAL color PIPE expresion
        | COLOR_BLOQUE IGUAL color PIPE expresion
        | FIGURA_BLOQUE IGUAL figura PIPE expresion
        | LETRA_BLOQUE IGUAL letra PIPE expresion
        | LETRA_SIZE_BLOQUE IGUAL expresion PIPE expresion
        ;

color ::=
        COLOR_HEX
        | rgb
        ;

rgb ::=
        expresion COMA expresion COMA expresion
        ;

figura ::=
        ELIPSE
        | CIRCULO
        | PARALELOGRAMO
        | RECTANGULO
        | ROMBO
        | RECTANGULO_REDONDEADO
        ;

letra ::=
        ARIAL
        | TIMES_NEW_ROMAN
        | COMIC_SANS
        | VERDANA
        ;

